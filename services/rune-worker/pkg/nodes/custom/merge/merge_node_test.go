package merge
package merge

import (
    "context"
    "testing"
    "time"

    redismock "github.com/go-redis/redismock/v9"
    "github.com/redis/go-redis/v9"

    "rune-worker/pkg/core"
    "rune-worker/pkg/messages"
    "rune-worker/plugin"
)

func TestMergeWaitForAllBarrierOpens(t *testing.T) {
    t.Parallel()












































































































































































































}    }        t.Fatalf("unexpected merged output")    if len(payloads) != 1 || merged["foo"] != float64(1) {    }        t.Fatalf("unexpected error: %v", err)    if err != nil {    merged, payloads, err := buildMergedContext(map[string]string{"a": `{"foo":1}`}, mergeModeAppend)func TestBuildMergedContext(t *testing.T) {}    }        t.Fatalf("expected error for odd length slice")    if _, err := decodeMergeResults([]interface{}{""] ); err == nil {func TestDecodeMergeResultsValidatesLength(t *testing.T) {}    }        t.Fatalf("unexpected override: %+v", overridden)    if overridden.WaitMode != waitModeAny || overridden.TimeoutSeconds != 42 {    overridden := parseMergeParams(map[string]any{"mode": "append", "wait_mode": waitModeAny, "timeout": "42"})    }        t.Fatalf("unexpected defaults: %+v", defaults)    if defaults.TimeoutSeconds != 300 || defaults.Mode != mergeModeAppend || defaults.WaitMode != waitModeAll {    defaults := parseMergeParams(nil)func TestParseMergeParams(t *testing.T) {}    }        t.Fatalf("expected error for missing from_node")    if _, err := node.Execute(context.Background(), execCtx); err == nil {    node := NewMergeNode(execCtx)    }        RedisClient: client,        Input:       map[string]any{"val": 1},        Parameters:  map[string]any{"wait_mode": "wait_for_all"},        },            Edges: []core.Edge{{ID: "e1", Src: "a", Dst: "merge1"}},            Nodes: []core.Node{{ID: "merge1"}},        Workflow: core.Workflow{        NodeID:      "merge1",        ExecutionID: "exec1",    execCtx := plugin.ExecutionContext{    defer client.Close()    client, _ := redismock.NewClientMock()    t.Parallel()func TestMergeMissingFromNode(t *testing.T) {}    }        t.Fatalf("unmet redis expectations: %v", err)    if err := mock.ExpectationsWereMet(); err != nil {    }        t.Fatalf("expected branch ignored")    if ignored := out["_merge_ignored"].(bool); !ignored {    }        t.Fatalf("unexpected error: %v", err)    if err != nil {    out, err := node.Execute(context.Background(), execCtx)    node := NewMergeNode(execCtx)    mock.ExpectSetNX(lockKey, "b", 24*time.Hour).SetVal(false)    lockKey := "exec:exec1:node:merge1:lock"    }        RedisClient: client,        FromNode:    "b",        Input:       map[string]any{"val": 1},        Parameters:  map[string]any{"wait_mode": "wait_for_any"},        Workflow:    core.Workflow{},        NodeID:      "merge1",        ExecutionID: "exec1",    execCtx := plugin.ExecutionContext{    defer client.Close()    client, mock := redismock.NewClientMock()    t.Parallel()func TestMergeWaitForAnyIgnored(t *testing.T) {}    }        t.Fatalf("unmet redis expectations: %v", err)    if err := mock.ExpectationsWereMet(); err != nil {    }        t.Fatalf("expected winner a got %s", winner)    if winner := out["_merge_winner"].(string); winner != "a" {    }        t.Fatalf("unexpected error: %v", err)    if err != nil {    out, err := node.Execute(context.Background(), execCtx)    node := NewMergeNode(execCtx)    mock.ExpectSetNX(lockKey, "a", 24*time.Hour).SetVal(true)    lockKey := "exec:exec1:node:merge1:lock"    }        RedisClient: client,        FromNode:    "a",        Input:       map[string]any{"val": 1},        Parameters:  map[string]any{"wait_mode": "wait_for_any"},        Workflow:    core.Workflow{},        NodeID:      "merge1",        ExecutionID: "exec1",    execCtx := plugin.ExecutionContext{    defer client.Close()    client, mock := redismock.NewClientMock()    t.Parallel()func TestMergeWaitForAnyWinner(t *testing.T) {}    }        t.Fatalf("unmet redis expectations: %v", err)    if err := mock.ExpectationsWereMet(); err != nil {    }        t.Fatalf("expected arrived=1 got %d", arrived)    if arrived := out["_merge_arrived"].(int); arrived != 1 {    }        t.Fatalf("expected waiting true")    if waiting := out["_merge_waiting"].(bool); !waiting {    }        t.Fatalf("unexpected error: %v", err)    if err != nil {    out, err := node.Execute(context.Background(), execCtx)    node := NewMergeNode(execCtx)    mock.ExpectSCard(barrierKey + ":arrivals").SetVal(1)        SetErr(redis.Nil)    mock.ExpectEval(waitForAllScript, []string{barrierKey}, "a", `{"val":1}`, 2).    barrierKey := "exec:exec1:node:merge1:barrier"    }        RedisClient: client,        FromNode:    "a",        Input:       map[string]any{"val": 1},        Parameters:  map[string]any{"wait_mode": "wait_for_all"},        Workflow:    wf,        NodeID:      "merge1",        ExecutionID: "exec1",    execCtx := plugin.ExecutionContext{    }        Edges: []core.Edge{{ID: "e1", Src: "a", Dst: "merge1"}, {ID: "e2", Src: "b", Dst: "merge1"}},        Nodes: []core.Node{{ID: "merge1"}},    wf := core.Workflow{    defer client.Close()    client, mock := redismock.NewClientMock()    t.Parallel()func TestMergeWaitForAllWaiting(t *testing.T) {}    }        t.Fatalf("unmet redis expectations: %v", err)    if err := mock.ExpectationsWereMet(); err != nil {    }        t.Fatalf("expected merged val=2, got %v", merged["val"])    if merged["val"] != float64(2) {    merged := out["merged_context"].(map[string]any)    }        t.Fatalf("unexpected error: %v", err)    if err != nil {    out, err := node.Execute(context.Background(), execCtx)        SetVal([]interface{}{"a", `{"val":1}`, "b", `{"val":2}`})    mock.ExpectEval(waitForAllScript, []string{barrierKey}, "a", `{"val":1}`, 2).    barrierKey := "exec:exec1:node:merge1:barrier"    node := NewMergeNode(execCtx)    }        LineageStack: []messages.StackFrame{},        RedisClient: client,        FromNode:    "a",        Input:       map[string]any{"val": 1},        Parameters:  map[string]any{"wait_mode": "wait_for_all"},        Workflow:    wf,        NodeID:      "merge1",        ExecutionID: "exec1",    execCtx := plugin.ExecutionContext{    }        Edges: []core.Edge{{ID: "e1", Src: "a", Dst: "merge1"}, {ID: "e2", Src: "b", Dst: "merge1"}},        Nodes: []core.Node{{ID: "merge1"}},    wf := core.Workflow{    defer client.Close()    client, mock := redismock.NewClientMock()