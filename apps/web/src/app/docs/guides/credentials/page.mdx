# Managing Credentials

Learn how to securely store and use API keys, tokens, and other sensitive data in Rune.

## What are Credentials?

Credentials are encrypted secrets used to authenticate with external services when executing workflow nodes. Instead of hardcoding sensitive values into node parameters, you store them as credentials and attach them to nodes that need authentication.

All credential data is encrypted at rest using **Fernet symmetric encryption** (AES-128-CBC) before being stored in PostgreSQL.

## Credential Types

Rune supports 7 credential types:

| Type | Use Case |
|------|----------|
| `api_key` | API keys for REST services |
| `oauth2` | OAuth 2.0 tokens |
| `basic_auth` | Username/password for HTTP Basic Auth |
| `header` | Custom header-based authentication |
| `token` | Bearer tokens |
| `smtp` | SMTP server credentials for email sending |
| `custom` | Any custom key-value data |

## Creating a Credential

1. Navigate to **Credentials** in the sidebar
2. Click **Create Credential**
3. Fill in:
   - **Name** — Descriptive label (e.g., "GitHub API - Production")
   - **Type** — Select the credential type
   - **Data** — The secret values (key-value pairs)
4. Click **Save**

The credential data is immediately encrypted and stored. You'll never see the raw values again in the UI — only the credential name and type.

## Using Credentials in Nodes

### HTTP Node

Attach a credential to an HTTP node for automatic authentication:

**Basic Auth credential:**
- Rune automatically computes the Base64-encoded `Authorization: Basic <base64(username:password)>` header

**Header credential:**
- Rune injects a custom header with the credential's `field` name and `value`

### SMTP Node

SMTP nodes **require** a credential of type `smtp` with the following fields:

| Field | Description |
|-------|-------------|
| `host` | SMTP server hostname (e.g., `smtp.gmail.com`) |
| `port` | Server port (usually `587` for TLS or `465` for SSL) |
| `username` | Authentication username |
| `password` | Authentication password |

### How Credentials Are Resolved at Runtime

When you click **Run** on a workflow:

1. The API service loads the workflow definition
2. For each node that references a credential, the API:
   - Fetches the encrypted credential from PostgreSQL
   - Decrypts it using the Fernet encryption key
   - Injects the decrypted values into the node's credential field
3. The resolved workflow (with decrypted credentials) is sent to the Worker via RabbitMQ
4. The Worker uses the credentials during node execution

> **Security note:** Decrypted credentials only exist in memory during execution. They are never written to disk or logs.

## Sharing Credentials

Credential owners can share credentials with other team members:

1. Go to the credential's detail page
2. Click **Share**
3. Select a user from the directory
4. The shared user can now **use** the credential in their workflows

### Permission Model

| Action | Owner | Admin | Shared User |
|--------|-------|-------|-------------|
| View credential metadata | ✅ | ✅ | ✅ |
| Use in workflows | ✅ | ✅ | ✅ |
| Edit credential data | ✅ | ✅ | ❌ |
| Delete credential | ✅ | ✅ | ❌ |
| Share with others | ✅ | ❌ | ❌ |
| View who it's shared with | ✅ | ✅ | ❌ |
| Revoke own access | — | — | ✅ |

## Encryption Details

### How It Works

1. You enter credential data (e.g., `{ "apiKey": "sk_live_..." }`)
2. The data is serialized to JSON
3. Fernet encryption (`cryptography` library) encrypts the JSON string
4. The encrypted ciphertext is stored in PostgreSQL
5. On execution, the process is reversed — decrypt → parse → inject

### Encryption Key

The encryption key is configured via the `ENCRYPTION_KEY` environment variable. Generate one with:

```bash
python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
```

> **Warning:** If you lose or change this key, all existing credentials become unreadable. Back it up securely.

## Managing Credentials via API

### Create

```bash
POST /credentials/
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "GitHub API",
  "credential_type": "api_key",
  "credential_data": {
    "apiKey": "ghp_xxxxxxxxxxxx"
  }
}
```

### List All Accessible Credentials

```bash
GET /credentials/
Authorization: Bearer <token>
```

Returns credentials you own plus credentials shared with you, with permission flags (`is_owner`, `can_share`, `can_edit`, `can_delete`).

### Dropdown List (for UI)

```bash
GET /credentials/dropdown
Authorization: Bearer <token>
```

Returns a simplified list with just `id`, `name`, and `credential_type` — used in the workflow editor's credential picker.

### Update

```bash
PATCH /credentials/{credential_id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "GitHub API v2",
  "credential_data": { "apiKey": "ghp_new_key" }
}
```

### Share

```bash
POST /credentials/{credential_id}/share
Authorization: Bearer <token>
Content-Type: application/json

{
  "user_id": 5
}
```

### Delete

```bash
DELETE /credentials/{credential_id}
Authorization: Bearer <token>
```

## Best Practices

### Use Descriptive Names

```
❌ "API Key 1"
✅ "GitHub API - Production"
✅ "SendGrid SMTP - Notifications"
```

### Never Hardcode Secrets

Always use credentials instead of putting secrets directly in node parameters. This way you can rotate keys without editing every workflow.

### Rotate Credentials Periodically

Update credential values regularly. All workflows using the credential automatically pick up the new values on their next run.

### Use Separate Credentials per Environment

Create separate credentials for development and production to avoid accidental cross-environment calls.

## Next Steps

- [Understanding Nodes](/docs/guides/nodes) — Learn which nodes use credentials
- [Creating Workflows](/docs/guides/creating-workflows) — Build workflows with authenticated API calls
- [REST API Reference](/docs/api-reference/rest-api) — Full credentials API documentation
